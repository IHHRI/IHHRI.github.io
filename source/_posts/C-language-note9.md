---
title: C_language_note9
date: 2021-04-18 11:56:40
tags:
---

## 运算符&

- 获得变量的地址，它的操作数必须是变量

  - ```
    int i; printf("%x", &i);
    ```

  

- 地址的大小是否与int相同取决于编译器

  - ```
    int i; printf("%p", &i);
    ```

    

- ```
  int main()
  {
  	int a[10];
  	
  	printf("%p\n", &a);
   	printf("%p\n", a);
   	printf("%p\n", &a[0]);
   	printf("%p\n", &a[1]);
   	
  	return 0;
  } 
  ```

  **&a，a，&a[0]**地址一样；每个元素之间相差4个字节



## 指针（就是保存地址的变量）

- ```
  int* p = &i;  // p里面的值是i变量的地址
  ```

  ```
  int* p,q;
  int *p,q;
  （这两者的意思是一样的，p是一个指针而q是一个int类型的变量）
  ```

  
  
- ***是一个单目运算符，用来访问指针的值所表示的地址上的变量**

  ```
  int k = *p;  //k赋值
  *p = k + 1;  //*p的值被改变
  ```

  - 当地址的值在函数内发生改变，该值会传递到外面

  

- **在赋值号的左边叫左值，在右边叫右值**
  
  - 左值之所以叫左值，是因为出现在赋值号左边的不是变量，而是值，是表达式计算的结果

  
  
- **指针的使用**

  - 交换两个变量的值（函数返回多个值，某些值就只能通过指针返回）

    ```
    void swap(int *pa, int *pb)
    {
    	int t = *pa;
    	*pa = *pb;
    	*pb = t;
    }
    ```

    

  - 传入的参数实际上是需要保存带回的结果的变量

  

- **指针常见错误**

  - 定义了指针遍历，还没有指向任何变量，就开始使用指针

  

- **函数参数表中的数组实际上是指针**

  - sizeof(a) == sizeof(int*)

  - 但是可以用数组的运算符[]进行运算

  ```
  int sum(int *ar,int n);  	 与	 int sum(int ar[],int n);	 是等价的
  int sum(int *,int)；    		与	int sum(int [],int);		是等价的
  ```

  - 数组变量本身表达地址

    - ```
      int a[10]; int*p=a; //无需用&取地址
      ```

    - 但是数组的单元表达的是变量，需要用&取地址
    
    - 数组变量是const的指针，所以不能被赋值

  

- **指针计算**

  - 给一个指针加1表示要让指针指向下一个变量

    ```
    int a[10];
    int *p = a;
    *(p+1) -> a[1]
    *(p+n) <-> a[n]
    ```

    - 如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义

  - 这些算术运算可以对指针做：
    - 给指针加、减一个整数(**+,+=,-,-=**)
    - 递增递减(++/--)
    - 两个指针相减（结果是这两个数的差除以一个sizeof(int)=4，意思是这两个地址中间有几个这样类型的）
  - *p++
    - 取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
    - *的优先级虽然高，但没有++高
    - 常用于数组类的连续空间操作
  - 指针比较
    - <，<=，==，>，>=，!=都可以对指针做
    - 比较它们在内存中的地址
    - 数组中的单元的地址肯定是线性递增的
  - **0**地址
    - **0**地址通常是不能随便碰的地址
    - **0**地址可以用来表示特殊的事情：
      1. 返回的指针是无效的
      2. 指针没有被真正初始化（先初始化为0）
    - **NULL**是一个预定定义的符号，表示**0**地址

  

- **指针的类型**

  - 无论指向什么类型，所有的指针的大小都一样的，因为都是地址

  - 但是指向不同类型的指针是不能直接互相赋值的

    ![https://github.com/IHHRI/picture](https://raw.githubusercontent.com/IHHRI/picture/main/image-20210518220948726.png)

  - 类型转换

    - ```
      void*表示不知道指向什么东西的指针（计算时与char*相同，但不相通）
      ```

  
  
  
- **动态内存分配**

  - malloc

    ```
    #include <stdlib.h>
    void* malloc(size_t size)
    ...
    free(a)
    ```

    - 向malloc申请的空间的大小是以字节为单位的

    - 返回的结果是void*，需要类型转换为自己需要的类型

      例如，转换为int

      ```
      (int*)malloc(n*sizeof(int))
      ```

    - 如果申请失败则返回0，或者叫做NULL

  

- **free()**

  - 把申请得来的空间还给“系统”
  - 只能还申请来的空间的首地址
  - 常见问题
    - 申请了没free→长时间运行内存逐渐下降
    - free过了再free
    - 地址变过了，直接去free

